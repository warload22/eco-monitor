---
alwaysApply: true
---

You are an expert in Python, Flask, and full-stack web development for geospatial data visualization.
Key Principles

Write concise, technical responses with accurate, production-ready Python and JavaScript examples.

Use functional, declarative programming in Python; prefer pure functions and modules over deep class hierarchies where possible.

Prefer iteration (map, filter, list comprehensions) and modularization over code duplication.

Use descriptive variable names with auxiliary verbs (e.g., is_valid, has_measurements, should_update_map).

Use snake_case for directories, Python files, and variables (e.g., utils/data_loader.py, filtered_records).

Structure the project as a cohesive Flask application with clear separation of concerns.

Follow the Receive a Dictionary/Model, Return a Response (RORO-like) pattern in view functions: receive validated data, return a consistent Flask response (jsonify(), render_template()).

Python / Flask Guidelines

Use def for view functions and business logic. Async is not required for our stack (standard psycopg2).

Use type hints for all function signatures where practical. Use Pydantic models or dedicated functions in schemas.py for complex request/response validation.

File Structure:

text
eco_monitor/
├── app.py                      # Flask app factory & core app instance
├── config.py                   # Configuration (dev/prod, load from .env)
├── models.py                   # SQLAlchemy ORM models (or plain SQL abstractions)
├── schemas.py                  # Pydantic models for API validation
├── database.py                 # Database connection & session management
├── routes/                     # Blueprints
│   ├── __init__.py
│   ├── api_measurements.py     # Blueprint: /api/measurements
│   ├── map_view.py             # Blueprint: serves main map page
│   └── reports.py              # Blueprint: data reports & charts
├── static/
│   ├── css/                    # Bootstrap customizations (if any)
│   └── js/
│       ├── map.js              # Core Leaflet logic
│       └── filters.js          # UI filtering for map
├── templates/                  # Jinja2 templates
│   ├── base.html               # Base layout with Bootstrap 5 (CDN)
│   ├── index.html              # Main map page
│   └── report.html             # Report generation page
└── utils/                      # Pure helper functions
    ├── data_validation.py
    └── geo_utils.py
Use clear conditional blocks. For simple one-line conditionals, you can use: if not data: return jsonify({'error': 'No data'}), 400.

Error Handling and Validation

Prioritize error handling at the start of functions.

Use guard clauses and early returns for invalid parameters, missing data, or failed permissions.

The "happy path" should be the last, unindented block in the function.

Avoid unnecessary else blocks after a return.

Validate all external input: Use Pydantic in API routes, SQL parameterization (%s) for all database queries to prevent injection.

Implement consistent error responses:

python
# In an API blueprint
from flask import jsonify
@bp.route('/data')
def get_data():
    param = request.args.get('param_id')
    if not param:
        # Guard clause: early error return
        return jsonify({'error': 'Missing param_id'}), 400
    # Happy path
    data = fetch_data_from_db(param)
    return jsonify(data)
Log unexpected errors for debugging but return user-friendly messages.

Dependencies (Our Stack)

Backend: Flask, Pydantic, SQLAlchemy 2.x (optional but recommended for ORM), psycopg2-binary.

Database: PostgreSQL (use connection pooling in production).

Frontend: Bootstrap 5 (via CDN in base.html), Leaflet.js (via CDN), vanilla JavaScript or lightweight Alpine.js for interactivity if needed.

Other: python-dotenv for configuration.

Flask-Specific & Frontend Guidelines

Use Blueprints to organize routes. Register them in app.py.

Use @app.before_request and @app.teardown_appcontext for lifecycle management (DB sessions) sparingly.

For API routes, always return JSON with explicit status codes: return jsonify({'result': data}), 200.

For page routes, use render_template('page.html', context_var=value).

Frontend (Leaflet/Bootstrap):

Keep JavaScript in static/js/ modular. map.js should handle Leaflet initialization, layer management, and AJAX calls to our API.

Use Bootstrap's grid and components for a clean, responsive UI.

All interactions between the map (Leaflet) and data should go through our Flask API endpoints. Do not hardcode data in templates.

Example pattern in map.js:

javascript
// Fetch data from our Flask API
async function updateMapWithFilter(parameterId) {
    const response = await fetch(`/api/measurements?parameter_id=${parameterId}`);
    const geoJsonData = await response.json();
    // Clear and add new layers to Leaflet map
}
Performance & Security

Minimize blocking I/O in views. Use SQLAlchemy queries efficiently, LIMIT for large datasets.

Implement server-side pagination for API endpoints returning many records.

Never hardcode secrets (DB passwords, API keys). Use .env file and config.py.

Always use parameterized queries. Never concatenate strings into SQL.

Consider simple caching (e.g., Flask-Caching on @cache.memoize()) for expensive, static queries.

Key Conventions for This Project

Database First: Design the data model (models.py) based on the monitoring domain (measurements, parameters, locations).

API-Centric Backend: Even though we serve HTML pages, the core data flow is: Database -> Flask JSON API -> Leaflet Frontend.

Simplicity over Complexity: Choose a simple, working solution (plain SQL, a well-structured function) over an overly abstract one, unless the abstraction clearly reduces future duplication.

Code Clarity is Paramount: Write code for the next developer (or your future self). Use comments for "why," not "what."

References

Refer to Flask documentation for Blueprints, Application Structure, and Configuration.

Refer to Leaflet documentation for mapping patterns and GeoJSON integration.

Refer to Bootstrap documentation for responsive layout and components.
